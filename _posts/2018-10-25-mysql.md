---
title: MySQL 
description: MySQL学习使用
categories:
 - 技术栈
tags:
 - MySQL 
 - 技术栈
---


### 安装和基础配置
当前使用版本是5.7.24，apt安装的版本

#### 安装
```
$ sudo apt install mysql-server mysql-client
```

#### 编码配置
```
# 修改MySQL编码为UTF-8，一些情况下容易出编码问题，所以改成UTF-8
# shell
$ sudo vim /etc/mysql/conf.d/utf8_charset.cnf

# /etc/mysql/conf.d/utf8_charset.cnf，新建utf8_charset.cnf文件
[mysqld]
character-set-server=utf8
[client]
default-character-set=utf8

# shell
$ sudo service mysql restart
$ mysql -u root -p
mysql> show variables like "%character%"
+--------------------------+----------------------------+
| Variable_name            | Value                      |
+--------------------------+----------------------------+
| character_set_client     | utf8                       |
| character_set_connection | utf8                       |
| character_set_database   | utf8                       |
| character_set_filesystem | binary                     |
| character_set_results    | utf8                       |
| character_set_server     | utf8                       |
| character_set_system     | utf8                       |
| character_sets_dir       | /usr/share/mysql/charsets/ |
+--------------------------+----------------------------+ 
```

#### 账号安全
```
# 禁止mysql以管理员账号运行
# shell
$ sudo vim /etc/mysql/conf.d/user_security.conf

# /etc/mysql/conf.d/user_security.cnf 新建user_security.cnf文件
[mysqld]
user=mysql

# shell
$ sudo service mysql restart
$ ps -ef | grep mysql
mysql ........  /usr/sbin/mysqld  # 显示用户是mysql即可，安装mysql时会自动创建mysql用户

# 加强root口令
$ mysql -u root -p

# mysql
mysql> use mysql;
mysql> update user set authentication_string=password('******') where user='root';
mysql> flush privileges;

# shell
$ mysql -u root -p  # 密码变了即可

# 创建非root用户，平时使用非root用户连接
# mysql
mysql> use mysql
mysql> insert into user(host, user, authentication_string, ssl_cipher, x509_issuer, x509_subject) values('localhost', 'aaa', password('xxxxxx'), '', '', '');
mysql> flush privileges;
```

#### 日志
不是运维其他不分那么细致了，了解一些
```
# 日志
mysql> show variables like 'log_%';  # 查看所有日志

# my.ini中配置日志
log-error  # 错误日志
log  # 查询日志 
log-slow-queries  # 慢查询日志
log-update  # 更新日志
log-bin  # 二进制日志
```

#### 授权
```
# 赋予用户使用数据库权限
# grant 权限 on 数据库.* to 用户名@登录主机 identified by 密码
# 先使用root用户登录
mysql> create database testDB;
mysql> grant all privileges on testDB.* to 'aaa'@'localhost' identified by 'xxxxxx';  # mysql 8语句不同
mysql> flush privileges;

# 之后使用用户身份登录
mysql> show databases;  # 可以看到testDB即可
```

在业务范围内配置所需最小权限，远程访问IP、访问次数等限制，项目较小自己也不是运维不细致了解了有个概念

基本上做好mysql运行用户不用root，连接mysql的应用用户不是mysql的root用户即可，及时更新mysql版本

### 一些问题
MySQL5和MySQL8存在区别，测试环境和生产环境最好一致，目前遇到的一些问题都能很快查blog解决，别人都遇到过

Flask+Celery做每日定时任务都时候出过错，虽然不知道celery内部机制，但是是MySQL连接Timeout为8小时，超过8小时会出错（code2006），可以通过改配置`[mysqld]\nwait_timeout=108000`等方式改长解决这个问题，应该有更好的办法，感觉连接时间过长不好，ping去维持连接的话celery多一个任务不行


### 数据库设计
为什么要进行数据库设计

* 减少数据冗余
* 避免数据异常维护
    * 插入异常：如果某实体随着另一个实体的存在而存在，即缺少某个实体时无法表示这个实体，那么这个表就存在异常
    * 更新异常：如果更改表所对应的某个实体实例的单独属性时，需要将多行更新，那么就说这个表存在更新异常
    * 删除异常：如果删除表的某一行来反映某实体实例失效时导致另一个不同实体实例信息丢失，那么这个表中就存在删除异常
    * 存在插入异常必定存在更新和删除异常
* 节约存储空间
* 高效访问

设计过程

* 需求分析
    * 数据是什么
    * 数据有哪些属性
    * 数据和属性各自的特点有哪些
* 逻辑优化
    * 将需求转化为数据库逻辑模型
    * ER图逻辑建模并展示
* 物理设计
    * 根据数据库特点把逻辑设计转换成物理设计
* 维护优化
    * 新的需求进行建表
    * 索引优化
    * 大表拆分
    
#### 需求分析
以一个小型电子商务网站为例：包含用户、商品、订单、购物车、供应商模块

* 用户模块
    * 属性：用户名、昵称、密码等普通信息
    * 可选唯一标识属性：用户名、身份证、电话
    * 存储特点：随系统上线时间逐渐增加，需要永久存储
* 商品模块
    * 属性：商品编号、供应商、数量、价格
    * 可选唯一标识符：商品编码、商品名称和供应商名称组合
    * 存储特点：对于下线商品可以归档存储
* 订单模块
    * 属性：订单号、用户名、商品编码、商品名称、下单时间
    * 可选唯一标识符：订单号、用户商品和日期组合
    * 存储特点：永久存储且数量越来越大，需要分表、分库存储
* 购物车模块
    * 属性：用户名、商品编号、何时加入、购物车编号
    * 可选唯一标识：购物车编号、用户名和商品编号加入时间的组合
    * 存储特点：不用永久存储（设置归档、清理规则）
* 供应商模块
    * 属性：供应商编号、供应商名称、营业执照
    * 可选唯一标识：供应商编号、营业执照
    * 存储特点：永久存储
* 对应关系
    * 一对多：用户/订单、用户/购物车
    * 多对多：订单/商品、购物车/商品、商品/供应商

#### 逻辑设计
ER图说明

名词解释

* 关系：一个关系对用通常所说的一张表
* 元组：表中的一行即为一个元祖
* 属性：表中的一列即为一个属性，每个属性都有一个名称，称为属性名
* 码：关系中某个属性或者某几个属性的组合，用于区别每个元组
* 候选码：表中的某个属性组，它可以唯一确定一个元组
* 主码：一个关系有多个候选码，选定其中一个为主码
* 域：属性的取值范围
* 分量：元组中的一个属性值

todo: ER图

##### 数据库设计范式
* 可以粗略地理解为一张表结构所符合的某种设计标准的级别
* 数据库范式也分为1NF、2NF、3NF、BCNF、4NF、5NF，符合高一级范式的设计，必定符合低一级范式，例如符合2NF，必定符合1NF
* 一般设计关系型数据库，最多考虑到BCNF就够

##### 第一范式（1NF）
* 定义：数据库表中所有字段都是单一属性，不可再分的
* 1NF是所有关系型数据的最基本要求
* 第一范式要求数据库中的表都是二维表（行列表）
* 存在数据冗余过大，插入、删除、修改异常问题
    * 以学号、姓名、系名、系主任、课名、分数为表的元组设计学校课程数据库（码为（学号、课名组合），学号可确定系名、系主任、姓名，码确定分数）
    * 数据冗余：每个学生学号、姓名等重复多次
    * 插入异常：新建一个系，没有课程和学生，无法将系信息添加到表中（没有添加码，就没有完整确定的一条信息，码为（学号、课程组合））
    * 删除异常：将某个系中所有学生的记录删除，则系记录没有，但不代表不存在系
    * 修改异常：如学生转系，保留课程，需要联动修改系与系主任信息，系中学生全部转系，则系记录不再，单不代表系不存在

##### 第二范式（2NF）
* 定义：2NF在1NF的基础上，消除了数据库中的表的非主属性（包含在任意一个码中的属性称为主属性）对于码的部分函数依赖
* 部分函数依赖是指存在着候选码的某一属性决定非主属性的情况
* 判断符合2NF的方式是
    * 找出表中所有的码
    * 根据码找出所有主属性
    * 去除主属性后剩下的都是非主属性
    * 查看是否存在非主属性对码的部分函数依赖
* 例子
    * 对于1NF中的学校课程数据库表
    * 码为（学号、课名）
    * 主属性为学号、课名
    * 非主属性是系名、系主任、姓名、分数
    * 姓名、系名、系主任对学号存在部分函数依赖，学号即可确定，不需要课程，只有分数不是部分函数依赖
* 消除依赖
    * 上面例子将大数据表拆分成两个更小的数据表，拆分过程达到更高一级范式的要求，叫做“模式分解”
    * 课程表（学号、课名、分数）（码为（学号和课名组合））
    * 学生表（学号、姓名、系名、系主任）（码为学号）
* 模式分解达到更高范式要求的效果
    * 数据冗余：学生姓名、系名、系主任不向之前重复那么多次了，有改进
    * 插入信息：插入一个新系的信息，码学号为空，无改进
    * 删除信息：删除某个系所有学生，该系信息丢失，无改进
    * 修改信息：转系后修改系名和系主任，有改进，所有学生转系，系记录不在，无改进

##### 第三范式（3NF）
* 定义：3NF在2NF基础上，消除了非主属性对于码的传递函数依赖
* 传递函数依赖：当Y不包含与X，且X不函数依赖于Y前提下，Z函数依赖于Y，且Y函数依赖于X，就是Z传递函数依赖于X
* 例子
    * 对于上面的学校课程数据库表模式拆分后的学生表
    * 系主任函数依赖系名，系名函数依赖学号，不符合3NF要求
* 依赖消除
    * 选课表（学号、课名、分数）（码为（学号和课名组合））
    * 学生表（学号、姓名、系名）（码为学号）
    * 系表（系名、系主任）（码为系名）
* 模式拆分达到更高范式要求的效果
    * 数据冗余：系主任重复少了，有改进
    * 插入信息：插入新系，有记录，有改进
    * 删除信息：删除系所有学生，系记录在，有改进
    * 更新信息：更新系所有学生到其他系，系记录存在，有改进
    
##### BC范式（BCNF）
* 定义：在3NF的基础上，数据库表中不存在任何属性对码的传递函数依赖
* 可以说3NF是非关键字属性不存在对码的传递函数依赖，BCNF是码的属性也不存在对码传递函数依赖
* 例子
    * 仓库名，管理员，数量，物品名（码为（管理员，物品名组合）（仓库名、物品名组合））
    * 仓库名和管理员可以互为码
    * 数据冗余：仓库名、管理员不需要那么多次
    * 插入信息：新增一个仓库，没有物品和管理员，但物品不能为空，因为必定是码的一部分
    * 删除信息：删除仓库物品，仓库信息不存在了
    * 修改信息：修改物品到另一个仓库，仓库信息不存在了
* 依赖消除
    * 仓库（仓库名，管理员）（码为任一）
    * 库存（仓库名，物品名，数量）（码为物品名）
* 模式拆分达到更高范式要求的效果
    * 以上问题解决

#### 物理设计
* 选择合适的数据库管理系统
    * 只会MySQL
* 定义数据库、表和字段的命名规范
    * 可读性原则
    * 表意性原则
    * 长名原则（不适用缩写）
* 根据所选DBMS系统选择合适的字段类型
* 反范式化设计

##### 字段类型选择原则
列的数据类型一方面影响数据存储空间的开销，另一方面也会影响数据查询性能，当一个列可以选择多种数据类型时，应该优先考虑数字类型，其次时日期或者二进制类型，最后是字符类型，对于相同级别的数据类型，应该优先选择占用空间小的数据类型

* 在对数据进行比较（查询条件，JOIN条件及排序）操作时，同样的数据，字符处理往往比数字处理慢
* 数据库以页为单位，列长度越小，越有利于性能提升

一些原则

* char和varchar选择
    * 如果列中要存储的数据长度差不多是一致的，应考虑用char，否则应考虑用varchar
    * 当列中最大数据长度小于50byte，则一般也考虑用char（当然，如果这个列很少用，则基于节省空间和减少I/O考虑，还是可以选择用varchar）
    * 一般不宜定义大于50byte当char类型
* decimal与float如何选择
    * decimal用于存储精确数据，而float只能用于存储非精确数据，故精确数据只能选择用decimal类型
    * 由于float的存储空间开销一般比decimal小（精确到7位小数需要4byte，精确到15位小数需要8byte），故非精确数据优先选择float类型
* 时间类型如何存储
    * 使用int来存储时间字段优缺点是字段长度比datetime小，使用时要进行函数转换，只能存储到2038-1-19，2到32次满
    * 需要存储的时间粒度
 
##### 其他信息
* 瓶颈在数据库服务器时避免使用外键约束
    * 数据库需要维护外键的内部管理
    * 外键等于把数据的一致性事务实现，全部交给数据库服务器完成
    * 有了外键，当做一些设计外键字段的增、删、改操作之后，需要触发相关操作去检查，而不得不消耗资源
    * 外键还会因为需要请求对其他表内部枷锁而容易出现死锁情况
    * 不使用外键约束的情况下，关联列上一定要建立索引
    * 互联网行业不推荐使用外键：一般用户量大，并发量高，为此数据库服务器很容易成为瓶颈，尤其受IO能力限制，且不能轻易水平拓展，若是将数据一致性的控制放在事务中，也即让应用服务器承担此部分压力，而应用服务器一般都是可以做到轻松地水平的伸缩
    * 传统行业，不用过多考虑性能问题推荐使用外键，可以降低开发成本，借助数据库实现表和关联表的数据一致性问题，使用外键的方式，还可以做到开发人员和数据库设计人员的分工，为程序员分担工作量
* 避免使用触发器
    * 降低数据导入的效率
    * 可能会出现意想不到的数据异常
    * 使业务逻辑变得复杂
* 严禁使用预留字段
    * 无法准确知道预留字段的类型
    * 无法准确知道预留字段中存储的内容
    * 后期维护字段所要的成本，同增加一个字段所需要的成本是相同的
* 反范式化
    * 反范式化是为了性能和读取效率的考虑适当对第三范式进行违反，允许少量数据冗余，拿空间换时间，减少表的关联数量，增加数据的读取效率，反范式化一定要适度

#### 维护优化
* 维护数据字典
    * 第三方工具维护
    * 数据库自身备注字段来维护
* 维护索引
    * 出现在WHERE从句，GROUP BY从句，ORDER BY从句对列来建立索引
    * 可选择性高的列要放在索引前面
    * 索引中不要包括太长的数据类型
    * 索引不是越多越好，过多会降低写效率，也会降低读效率（索引过多选择索引列导致）
    * 定期维护索引碎片（引索引产生一些额外页中文件）
    * 在SQL语句中不要使用强制索引关键字（有优化器自动，索引变化要改代码）
* 维护表结构
* 在适当时候对表进行水平拆分或垂直拆分
    * 垂直拆分，表太宽，分成两张表，条数不变，属性分到两张表中
    * 水平拆分，表太长，hash主键平均分到几张表

```
建表
CREATE TABLE customer(
    cust_id INT AUTO_INCREMENT NOT NULL COMMENT '自增ID',
    cust_name VARCHAR(10) NOT NULL COMMENT '客户名称',
    PRIMARY KEY (cust_id)
) COMMENT '客户表'

导出数据字典
SELECT a.table_name, b.TABLE_COMMENT, a.COLUMN_NAME, a.COLUMN_TYPE, a.COLUMN_COMMENT FROM information_schema.COLUMNS a JOIN information_schema.TABLES b on a.table_schema=b.table_schema AND a.table_name=b.table_name WHERE a.table_name='customer'
```

