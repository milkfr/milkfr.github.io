---
title: Docker
description: Docker学习与我的常用
categories:
 - Docker
tags:
 - Docker
 - 技术栈
---

需要用到的Docker功能有
1. 私有registry部署供小团队使用
2. Python Web的环境部署
3. 分布式代理扫描工具部署

### 程序部署思路

### 搭建私有仓库
#### 本地仓库
```
# Run a local registry
$ docker run -d -p 5000:5000 --restart=always --name registry registry:2
$ docker run -d -e REGISTRY_HTTP_ADDR=0.0.0.0:5001 -p 5001:5001 --name -v /mnt/registry:/var/lib/registry reigstry registry:2

# Copy an image from Docker Hub to your registry
$ docker pull ubuntu:16.04
$ docker tag ubuntu:16.04 localhost:5000/my-ubuntu
$ docker push localhost:5000/my-ubuntu
$ docker image remove ubuntu:16.04
$ docker image remove localhost:5000/my-ubuntu
$ docker pull localhost:5000/my-ubuntu

# Stop a local registry
$ docker container stop registry
$ docker container stop registry && docker container rm -v registry
```

#### 私有仓库
生成证书

openssl生成根证书，根证书签名registry域名，客户端信任根证书，可以使用我写的[工具](https://github.com/milkfr/certs)

```
$ mkdir -p certs
$ cp ca.crt certs/domain.crt
$ cp ca.key certs/domain.key
$ sudo docker container stop registry
$ sudo docker run -d --restart=always --name registry -v `pwd`/certs:/certs -e REGISTRY_HTTP_ADDR=0.0.0.0:443 -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key -p 443:443 registry:2
```

浏览器访问：https://domain/v2/ 没有证书问题

访问控制

```
$ mkdir auth
$ sudo docker run --entrypoint htpasswd registry:2 -Bbn testuser testpassword > auth/htpasswd
$ sudo docker container stop registry
$ sudo docker run -d --restart=always --name registry -v `pwd`/certs:/certs -e REGISTRY_HTTP_ADDR=0.0.0.0:443 -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key -p 443:443 -v `pwd`/auth:/auth -e "REGISTRY_AUTH=htpasswd" -e "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm" -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd registry:2
```

浏览器访问：https://domain/v2/_catalog 提示登录

简单操作
```
# login domain registry
$ sudo docker login domain

# Copy an image from Docker Hub to your registry
$ sudo docker pull ubuntu:16.04
$ sudo docker tag ubuntu:16.04 localhost:5000/my-ubuntu
$ sudo docker push localhost:5000/my-ubuntu
$ sudo docker image remove ubuntu:16.04
$ sudo docker image remove localhost:5000/my-ubuntu
$ sudo docker pull localhost:5000/my-ubuntu

# Stop a local registry
$ sudo docker container stop registry
$ sudo docker container stop registry && docker container rm -v registry
```

用Compose部署
```
$ mkdir registry
$ cd registry
$ mkdir certs
$ cp /path/certs/* certs/
$ mkdir auth
$ sudo docker run --entrypoint htpasswd registry:2 -Bbn testuser testpassword > auth/htpasswd 

$ vim docker-compose.yml
# docker-compose.yml
# replace /path with the directory which contains the certs/ and auth/ directories
# replace domain with your domain name
registry:
  restart: always
  image: registry:2
  ports: 
    - 5000:5000
  environment:
    REGISTRY_HTTP_TLS_CERTIFICATE: /certs/domain.crt
    REGISTRY_HTTP_TLS_KEY: /certs/domain.key
    REGISTRY_AUTH: htpasswd
    REGISTRY_AUTH_HTPASSWD_PATH: /auth/htpasswd
    REGISTRY_AUTH_HTPASSWD_REALM: Registry Realm
  volumns:
    - ./data:/var/lib/registry
    - ./certs:/certs
    - ./auth:/auth

# start your registry by issuing the following command in the directory containing the docker-compose yml file
$ sudo docker-compose up -d
```

#### 清理过时版本

#### 集群服务

### Docker Python Web
Python+Flask+Gunicorn+MySQL+Nginx+Elasticsearch

> 个人的经验是，将你的源代码以卷的方式映射到容器中，容器只保留tomcat等固定设置，每次build直接attach卷到已有容器中就可以了。或者将tomcat+ java等做成base image，每次build其实很快的。

> 1. 你的dockerfile和java的代码都保存在github（也可以是其他的地方），然后本地修改代码，修改好了，commit到github的staging分支上去。
> 2. 这时候CI会自动为你在staging上跑测试。
> 3. 当测试通过后，你去把代码merge到master，然后master会再次运行CI，并自动根据你的代码构建镜像。
> 4. 镜像构建好之后，会推送到你相应的私有repository去。
> 5. 当有新版本的镜像被推送后，会自动部署到production

> 这样就完成了一个开发部署的闭环，也是tutum所宣传的container platform
> 开发者只需要专注于开放，当代码提交后，平台会自动部署代码到生产环境，这就是最大的优点

### Docker 常用

### Docker安全
Docker的安全问题主要有以下一些

* Docker镜像安全
    * 恶意镜像
    * 非恶意但存在恶意软件
    * 镜像软件本身不安全
    * 中间人篡改镜像
* Docker自生漏洞，曾出现代码执行、权限提升等一些CVE
* Docker设计安全缺陷
    * 同一主机容易构成局域网，类似ARP欺骗等可用
    * DDoS耗尽资源，cgroups缺陷，单一容易分配过多资源会导致该问题
    共享root，以root运行容易，容器root用户也拥有宿主机root权限
    * 有一些重要文件未被隔离，/sys/proc等
    * 缺少完整等用户namespace实现，类似共享root，以root运行容易，容器root用户也拥有宿主机root权限
* Docker deamon安全（未授权访问等）

#### Docker安全规则
* 镜像安全
    * 从信任的库中获取镜像且使用TLS认证
    * Dockerfile中为容器创建非root用户，非一定要root执行的命令（类似apt）切换到这个user执行
    * 如无必要以非root用户运行容器进程
    * 减少镜像中不必要到依赖库和软件
* Docker镜像使用
    * 资源限制
    * suid和guid限制
    * 文件系统限制
* 守护进程安全
    * 只允许受信用户控制Docker守护进程，用户验证
    * TLS和镜像仓库验证
    * 限制容器之间通信，无必要限制通信功能
* 其他
    * Docker及时更新，宿主机内核漏洞控制
    * 生产环境不实用开发者工具(boot2docker，kinematic)
    * 限制容器使用Linux内核的能力和资源，为守护进程设置受限的资源控制(-ulimit)
    * 不实用Privileged容器，使用--privileged参数将授予容器与主机几乎相同的权限
    * 指定容器重启策略为on-failure
    * 使用Seccomp和AppArmor、SELinux保证额外安全层
    * https://zhuanlan.zhihu.com/p/43586159