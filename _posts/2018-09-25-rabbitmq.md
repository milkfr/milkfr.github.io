---
title: RabbitMQ
description: RabbitMQ学习使用
categories:
 - 扫描器开发
tags:
- RabbitMQ
- 技术栈
- 扫描器 
---


### 环境搭建
#### 开发环境
官网文档非常全面，直接参考即可

在MAC的OS X上
```
$ brew update
$ brew install rabbitmq
$ export PATH=$PATH:/usr/local/sbin  # 之后可以使用rabbitmq-server
$ brew services start rabbitmq  # 没有上面一步可以用这种方式启动
$ rabbitmq-server -detached  # 后台进程运行
$ rabbitmqctl status  # 查看状态
$ rabbitmqctl cluster_status  # 查看集群状态
```

#### 生产环境D


#### Docker部署

### 基础概念
* Server: 称Broker，接收客户端的连接，实现AMQP实体服务
* Connection: 连接，应用程序与Broker的网络连接(TCP连接)
* Channel: 网络信道(一个TCP连接可以有多个Channel，多线程共享不安全)，几乎所有的操作都在Channel中进行，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。Channel是进行消息读写的通道。客户端可以建立多个Channel，每个Channel代表一个会话任务
* Message: 消息，服务器和应用程序之间传送的数据，由Properties和Body组成。Properties可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容
* Virtual host: 虚拟地址，用于进行逻辑隔离，最上层的消息路由。一个Virtual host可以有若干个Exchange和Queue，同一个Virtual host里面不能有相同的Exchange和Queue
* Exchange: 交换机，接收消息，根据路由键转发消息到绑定的队列（以下是常用交换机）
    * direct: 如果路由键匹配，消息就投递到对应到队列
    * fanout: 投递消息给所有绑定在当前交换机上面到队列
    * topic: 允许实现有趣到信息通信场景，使得不同源头消息能够达到同一队列（正则匹配）
* Binding: Exchange和Queue之间的虚拟连接，binding中可以包含routing key
* Routing key: 一个路由规则，虚拟机可用它来确定如何路由一个特定消息
* Queue: 也称为Message Queue，消息队列，保存消息并将它们转发给消费者，多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理
* 生产者和消费者

### 运转流程
Connect(TCP连接)
Channel(通道，一个TCP连接可以有多个通道，多线程共享不安全)
ExchangeDeclare(声明交换机)
QueueDeclare(声明队列)
QueueBind(队列绑定交换机)
ExchangeBind(交换机绑定交换机)
交换机与队列：RabbitMQ的消息存储在队列中，交换机的使用并不真正耗费服务器的性能，而队列会，如果要衡量RabbitMQ的当前的QPS只需看队列即可，实际使用中，对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值，以便在固定硬件资源的情况下能够进行合理有效的分配，生产者和消费者都应该尝试创建（这里指Declare操作）队列，在上线前创建更好，预先创建资源可以免去声明过程也可以确保交换机和队列能够正确地绑定匹配
Publish(发送消息)
Consume(推模式，持续订阅的方式来消费信息)，将信道设置为接收模式，知道取消队列订阅，期间RabbitMQ会不断地推送消息给消费者，受到QOS限制
Get(拉模式，单挑获取消息的消费方式而不是持续订阅，不能用循环代替推模式，这样会严重影响性能，高吞吐量用推模式)

