---
title: RabbitMQ
description: RabbitMQ学习使用
categories:
 - 扫描器开发
tags:
- RabbitMQ
- 技术栈
- 扫描器 
---


### 环境搭建
#### 开发环境
官网文档非常全面，直接参考即可

在MAC的OS X上
```
$ brew update
$ brew install rabbitmq
$ export PATH=$PATH:/usr/local/sbin  # 之后可以使用rabbitmq-server
$ brew services start rabbitmq  # 没有上面一步可以用这种方式启动
$ rabbitmq-server -detached  # 后台进程运行
$ rabbitmqctl status  # 查看状态
$ rabbitmqctl cluster_status  # 查看集群状态
```

#### 生产环境D


#### Docker部署

### 基础概念
* Producer: 消息生产者
* Consumer: 消息消费者
* Server: 称Broker，一种传输服务，维护一条从Producer到Consumer到路线，保证数据按指定方式传输，商业系统需要再做一层数据一致性到guard
* Connection: 连接，应用程序与Broker的网络连接(TCP连接)
* Channel: 网络信道(一个TCP连接，也就是Connection，可以有多个Channel，多线程共享不安全)，几乎所有的操作都在Channel中进行，包括定义Queue和Exchange、绑定Queue与Exchange、发布消息等。Channel是进行消息读写的通道。客户端可以建立多个Channel，每个Channel代表一个会话任务
* Message: 消息，服务器和应用程序之间传送的数据，由Properties和Body组成。Properties可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容
* Virtual host: 虚拟地址，用于进行逻辑隔离，最上层的消息路由。一个Virtual host可以有若干个Exchange和Queue，同一个Virtual host里面不能有相同的Exchange和Queue
* Exchange: 交换机，接收消息，根据路由键转发消息到绑定的队列（以下是常用交换机）
    * direct: 如果路由键匹配，消息就投递到对应到队列
    * fanout: 投递消息给所有绑定在当前交换机上面到队列
    * topic: 允许实现有趣到信息通信场景，使得不同源头消息能够达到同一队列（正则匹配）
    * Routing key, Binding key: 用来指定路由规则，Exchange Type和Routing Key，Binding key都匹配时消息流向决定，实际上只有Routing key，为了区分我们把交换机和队列绑定时传到参数叫做Binding key，把发送消息时带到参数叫Routing key
* Queue: 也称为Message Queue，消息队列，保存消息并将它们转发给消费者，多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理
* Consume: 推模式，持续订阅的方式来消费信息，将信道设置为接收模式，知道取消队列订阅，期间RabbitMQ会不断地推送消息给消费者，受到QOS限制
* Get: 拉模式，单挑获取消息的消费方式而不是持续订阅，不能用循环代替推模式，这样会严重影响性能，高吞吐量用推模式
* VirtualHost: 类似与MySQL中都库，每个VirtualHost相当于一个相对独立的database，独立的RabbitMQ服务器，每个VirtualHost相互隔离

### 常用命令
```
$ rabbitmq-server -detached  # 启动rabbitmq，-detached代表后台守护进程方式启动
$ rabbitmq status  # 查看状态
$ rabbitmq stop  # 关闭服务
$ rabbimtq list_users  # 列出角色
```

### 网页插件
```
# 启动
$ sudo mkdir /etc/rabbitmq  # 先创建目录，不然可能会报错
$ rabbitmq-plugins enable rabbimq_management  # 启用插件
$ rabbitmq-plugins disable rabbitmq_management  # 关闭插件

# 默认不允许访问，需要增加admin用户权限
rabbitmqctl add_user admin xxxxxx
rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"  # 增加权限， / 代表所有virtualhost
rabbitmqctl set_user_tags admin administrator  # 修改用户角色
```
之后可以在http://ip:15672登录，之后把guest用户删除


### 用户与权限
```
$ rabbitmqctl add_user {username} {password}  # 新增角色
$ rabbitmqctl delete_user {username}  # 删除角色
$ rabbitmqctl change_password {username} {newpassword}  # 修改密码
$ rabbitmqctl set_user_tags {username} {tag ...}  # 设置角色类型
# Tag可以是administrator,monitoring,policymaker,management,none,相应权限见官网
# none: 无任何角色，新创建的角色默认为none
# management: 可以访问Web管理页面
# policymaker: 包含management所有权限，并且可以管理Policy和Parameter
# monitoring: 包含management所有权限，并且可以看到所有连接、信道及节点相关信息
# administrator: 代表最高权限
$ rabbitmqctl add_vhost [vhost]
$ rabbitmqctl set_permissions -p [vhost] {user} {conf} {write} {read}
# vhost: 当vhost==/时代表所有vhost
# Conf: 一个正则表达式match哪些配置资源能够被该用户访问
# Write: 一个正则表达式match哪些配置资源能够被该用户读
# Read: 一个正则表达式match哪些配置资源能够被该用户访问
```

### 常用配置

### SSL通信

### 运转流程
Connect(TCP连接)
Channel(通道，一个TCP连接可以有多个通道，多线程共享不安全)
ExchangeDeclare(声明交换机)
QueueDeclare(声明队列)
QueueBind(队列绑定交换机)
ExchangeBind(交换机绑定交换机)
交换机与队列：RabbitMQ的消息存储在队列中，交换机的使用并不真正耗费服务器的性能，而队列会，如果要衡量RabbitMQ的当前的QPS只需看队列即可，实际使用中，对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值，以便在固定硬件资源的情况下能够进行合理有效的分配，生产者和消费者都应该尝试创建（这里指Declare操作）队列，在上线前创建更好，预先创建资源可以免去声明过程也可以确保交换机和队列能够正确地绑定匹配
Publish(发送消息)

### 常用案例
* 消息保障100%的投递成功
    * 保障消息的成功发出
    * 保障MQ节点的成功接受
    * 发送端到MQ节点（Broker）确认应答
    * 完善的消息补偿机制
    * 方案
        * 消息落库，对消息状态进行标记
        * 消息的延迟投递，做二次确认，回调检查（这种方式相比第一种减少了数据库操作）
* 幂等性概念
    * 对同一事物执行多次的执行结果相同
    * 唯一ID+指纹码机制，利用数据主键去重
        * 好处实现简单
        * 坏处高并发下有数据库写入瓶颈
        * 解决方案：根据ID进行分库分表进行路由算法
    * Redis原子性
        * 是否要进行数据落库，如果落库，关键解决的问题是数据库和缓存如何做到原子性
        * 如果不落库，那么都存储到缓存中，如何设置定时同步策略
* 海量业务高峰期，如果避免消息的重复消费问题
* Confirm确认消息、Return返回消息
* 自定义消费者
* 消息的ACK与重回队列
* 消息的限流
* TTL消息
* 死信队列

